{"version":3,"names":[],"mappings":"","sources":["spec.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports=[\n  {\n    \"title\": \"Alice in Wonderland\",\n    \"text\": \"Alice falls into a rabbit hole and enters a world full of imagination.\"\n  },\n\n  {\n    \"title\": \"The Lord of the Rings: The Fellowship of the Ring.\",\n    \"text\": \"An unusual alliance of man, elf, dwarf, wizard and hobbit seek to destroy a powerful ring.\"\n  }\n]\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar InvertedIndex = require('../../js/Inverted-index.js');\n\nvar index = new InvertedIndex();\n\nvar Utils = require('../../js/Utils.js');\n\nvar books = require('../books.json');\n\ndescribe('Read book data', function () {\n  it('Should return a valid JSON array', function () {\n    expect(Array.isArray(books)).toBe(true);\n  });\n  it('Should return a non empty JSON array', function () {\n    expect(books.length > 1).toBe(true);\n  });\n  it('Should remove duplicates from array', function () {\n    var duplicate = ['a', 'b', 'c', 'd', 'e', 'a', 'b', 'c', 'd', 'e'];\n    expect(Utils.unique(duplicate)).toEqual(['a', 'b', 'c', 'd', 'e']);\n  });\n  it('Should return a JSON array which contains objects only', function () {\n    var answer = true;\n    var count = 0;\n    while (count < books.length) {\n      if (_typeof(books[count]) != 'object' || Array.isArray(books[count])) {\n        answer = false;\n      }\n      count += 1;\n    }\n    expect(answer).toBe(true);\n  });\n  it('Should return a JSON array which has keys (title and text)', function () {\n    var answer = true;\n    var count = 0;\n    while (count < books.length && answer) {\n      if (books[count].title === undefined || books[count].text === undefined) {\n        answer = false;\n      }\n      count += 1;\n    }\n    expect(answer).toBe(true);\n  });\n  // it('Should return a JSON array which has valid string entries for keys(title, text)', () => {\n  //   let answer = true;\n  //   let count = 0;\n  //   while(count < books.length){\n  //     if(typeof books[count].title != 'string' || typeof books[count].text != 'string'){\n  //       answer = false;\n  //     }\n  //     count += 1;\n  //   }\n  //   expect(answer).toBe(true);\n\n  // });\n  // it('Should return the correct filename of the uploaded file', () => {\n  //   let answer = Utils.formatFileName('src/jasmine/books.json');\n  //   expect(answer).toEqual('books.json');\n\n  // });\n});\n\n// describe('Populate Index', () => {\n//   describe('On file upload', () => {\n//     it('Should create the index once the JSON file has been read', () => {\n//       expect(typeof index.reference['books.json']).toEqual('object');\n\n//     });\n\n//     it('Should create an accurate index object', () => {\n//       expect(index.getIndex('books.json').alice[0]).toEqual(0);\n//       expect(index.getIndex('books.json').lord[0]).toEqual(1);\n//       expect(index.getIndex('books.json').a[1]).toEqual(1);\n\n//     });\n//     it('Should create an inverted index', () => {\n//       let verdict = true;\n//       const indexContent = index.reference['books.json'];\n\n//       for (value in indexContent) {\n//         if (!Array.isArray(indexContent[value]) || isNaN(indexContent[value][0])) {\n//           verdict = false;\n//         }\n//       }\n//       expect(verdict).toEqual(true);\n\n//     });\n//     it('Should not overwrite the previously created index', () => {\n//       const indexBefore = index.reference['books.json'];\n//       const indexAfter = index.reference['tests.json'];\n//       expect(typeof indexBefore == 'object' && typeof indexAfter == 'object').toBe(true);\n\n//     });\n//   });\n// });\n\n// describe('Search Index', () => {\n//   describe('Search results', () => {\n//     it('Should return the correct result for single word searches', () => {\n//       expect(typeof index.searchIndex('Lord')).toEqual('object');\n\n//     });\n//     it('Should filter alphanumeric search queries', () => {\n//       expect(index.searchIndex('ade **')).toEqual(10);\n\n//     });\n\n//     it('Should return correct search results for multiple word queries', () => {\n//       expect(index.searchIndex('Lord of the rings')).toEqual(0);\n\n//     });\n//   });\n\n// it(' - The search should not take too long to execute', () => {\n//   const startTime = performance.now();\n//   index.searchIndex(['valid1.json'], index.createResultHtml, 'alice');\n//   const endTime = performance.now();\n//   expect(endTime - startTime < 5000).toBeTruthy();\n//   \n// });\n\n// it('should accept a varied number of argument', () => {\n//   let result = index.searchIndex(['valid1.json'], index.createResultHtml, 'alice in', 'lord town');\n//   expect(typeof result[0]).toEqual('object');\n//   result = index.searchIndex(['valid1.json'], index.createResultHtml, 'alice in', ['lord', 'town']);\n//   expect(typeof result[0]).toEqual('object');\n//   result = index.searchIndex(['valid1.json'], index.createResultHtml, 'alice', 'in');\n//   expect(result[0]).toEqual({ alice: { 'valid1.json': [0] }, in : { 'valid1.json': [0] } });\n//   \n// });\n\n// it('It should accept an array of argument', () => {\n//   const result = index.searchIndex(['valid1.json'], index.createResultHtml, ['alice', 'in']);\n//   expect(result[0]).toEqual({ alice: { 'valid1.json': [0] }, in : { 'valid1.json': [0] } });\n//   \n// });\n\n\n// it('It should accept mix of array and words as argument', () => {\n//   result = index.searchIndex(['valid1.json'], index.createResultHtml, 'alice in', ['lord', 'town']);\n//   expect(typeof result[0]).toEqual('object');\n//   \n// });\n\n// describe('Get Index', () => {\n//   it('should take the filename of the indexed JSON data', () => {\n//     expect(typeof index.getIndex('valid1.json')).toEqual('object');\n//   });\n// });\n// });\n\n},{\"../../js/Inverted-index.js\":3,\"../../js/Utils.js\":4,\"../books.json\":1}],3:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Class for creating an inverted index.\n */\nvar InvertedIndex = function () {\n  /**\n  * Instantiate an inverted index object.\n  * @param {object} reference - The utility class.\n  */\n  function InvertedIndex(utils) {\n    _classCallCheck(this, InvertedIndex);\n\n    this.utility = utils;\n    this.reference = {};\n    this.documentFiles = {};\n    this.currentDocuments = [];\n    this.allWords = [];\n  }\n\n  /**\n  * Create an inverted index from file\n  * @param {string} url - The json file url.\n  * @returns {object} The reference object for current file.\n  */\n\n\n  _createClass(InvertedIndex, [{\n    key: 'createIndex',\n    value: function createIndex(url) {\n      var _this = this;\n\n      /* eslint-disable no-unused-vars */\n      /* eslint-disable consistent-return */\n      return new Promise(function (resolve, reject) {\n        _this.utility.getJSON(url, function (data) {\n          resolve(data.response);\n        });\n      }).then(function (jsonObject) {\n        try {\n          if (_this.utility.isValidJson(jsonObject)) {\n            var savedTokens = _this.utility.saveTokens(jsonObject);\n            var documentName = _this.utility.formatFileName(url);\n            _this.utility.populateReference(savedTokens.tokens, _this, documentName);\n            _this.currentDocuments.push(documentName);\n            _this.allWords = _this.utility.unique(_this.allWords.concat(savedTokens.words));\n            return _this.reference[documentName];\n          }\n        } catch (error) {\n          throw error;\n        }\n      });\n    }\n\n    /**\n    * Get Created inverted index.\n    * @param {string} documentName - The file name of currently indexed document.\n    * @returns {object} The reference object for current file.\n    */\n\n  }, {\n    key: 'getIndex',\n    value: function getIndex(documentName) {\n      return this.reference[documentName];\n    }\n\n    /**\n    * Search the inverted index.\n    * @param {string} value - The current search query.\n    * @param {array} documentNames - an array of current files to searxh.\n    * @returns {object} An object with the accurate searxh results.\n    */\n\n  }, {\n    key: 'searchIndex',\n    value: function searchIndex(value, documentNames) {\n      var _this2 = this;\n\n      /* eslint-disable no-unused-expressions */\n      /* eslint-disable no-unused-vars */\n      /* eslint-disable no-nested-ternary */\n      this.searchReturn = {};\n      if (value !== (null || undefined) && documentNames.length > 0) {\n        this.utility.inputFIlter(value).filter(function (word) {\n          return _this2.allWords.indexOf(word) !== -1;\n        }).forEach(function (word) {\n          documentNames.forEach(function (documentFile) {\n            var docKeys = Object.keys(_this2.reference[documentFile]);\n            _typeof(_this2.searchReturn[documentFile]) === 'object' && !Array.isArray(_this2.searchReturn[documentFile]) ? docKeys.indexOf(word) !== -1 ? _this2.searchReturn[documentFile][word] = _this2.reference[documentFile][word] : null : docKeys.indexOf(word) !== -1 ? (_this2.searchReturn[documentFile] = {}, _this2.searchReturn[documentFile][word] = _this2.reference[documentFile][word]) : null;\n          });\n        });\n        return this.searchReturn;\n      }\n    }\n  }]);\n\n  return InvertedIndex;\n}();\n\nmodule.exports = InvertedIndex;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Utils = function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, null, [{\n    key: 'unique',\n\n    /** remove array duplicates.\n    * @param {array} arr - The array to be filtered.\n    * @returns {array} The filtered array.\n    */\n    value: function unique(array) {\n      if (Array.isArray(array)) {\n        var _ret = function () {\n          var checked = {};\n          return {\n            v: array.filter(function (item) {\n              if (!checked[item]) {\n                checked[item] = true;\n                return item;\n              }\n              return null;\n            })\n          };\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n      return [];\n    }\n\n    /**\n    * JSON file reader.\n    * @param {string} url - The url of JSON file.\n    * @param {function} callback - the callback function\n    * takes in the responseData parameter as argument.\n    * @returns {function} The callback value.\n    */\n\n  }, {\n    key: 'getJSON',\n    value: function getJSON(url, callback) {\n      /* eslint-disable no-undef */\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'json';\n      xhr.onreadystatechange = function changed() {\n        if (this.readyState === XMLHttpRequest.DONE) {\n          if (this.status === 200) {\n            return callback(this);\n          }\n        }\n        return this.statusText;\n      };\n      xhr.onerror = xhr.statusText;\n      xhr.send();\n    }\n\n    /**\n    * check if object is a valid json file.\n    * @param {object} jsonObject - The JSON file content.\n    * @returns {boolean} ans - The check for jsonObject validity.\n    */\n\n  }, {\n    key: 'isValidJson',\n    value: function isValidJson(jsonObject) {\n      try {\n        var jsonObjectKeys = Object.keys(jsonObject);\n        var _jsonObjectLength = jsonObjectKeys.length;\n      } catch (error) {\n        return false;\n      }\n      var count = 0;\n      var ans = true;\n      if (jsonObjectLength > 0) {\n        while (count < jsonObjectLength) {\n          var hasValidTitle = jsonObject[count].title !== undefined && jsonObject[count].title.length > 0 && typeof jsonObject[count].title === 'string';\n          var hasValidText = jsonObject[count].text !== undefined && jsonObject[count].text.length > 0 && typeof jsonObject[count].text === 'string';\n          if (!(hasValidTitle && hasValidText)) {\n            ans = false;\n            return ans;\n          }\n          count += 1;\n        }\n      } else {\n        ans = false;\n      }\n      return ans;\n    }\n\n    /**\n    * format file url to acceptable file name format.\n    * @param {string} url - the current file url.\n    * @returns {string} The new valid file name.\n    */\n\n  }, {\n    key: 'formatFileName',\n    value: function formatFileName(url) {\n      try {\n        var matcher = new RegExp(/\\/\\w+.json/, 'gi');\n        return matcher.exec(url).toString().slice(1);\n      } catch (error) {\n        throw error;\n      }\n    }\n\n    /**\n    * save file and sort docs in json.\n    * @param {object} jsonObject - a json object.\n    * @returns {object} an object containing he saved tokens and jsonObject.\n    */\n\n  }, {\n    key: 'saveTokens',\n    value: function saveTokens(jsonObject) {\n      var _this = this;\n\n      try {\n        var _ret2 = function () {\n          var tokens = {};\n          var words = [];\n          jsonObject.forEach(function (documentObject, index) {\n            var token = '';\n            token = documentObject.title + ' ' + documentObject.text;\n            var uniqueTokens = _this.unique(token.toLowerCase().match(/\\w+/g).sort());\n            tokens[index] = uniqueTokens;\n            words = words.concat(uniqueTokens);\n          });\n          return {\n            v: { tokens: tokens, jsonObject: jsonObject, words: words }\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      } catch (error) {\n        throw error;\n      }\n    }\n\n    /**\n    * populate the object reference and document attribute.\n    * @param {object} jsonObject - the jsonObject.\n    * @param {object} parent - the current (this) object.\n    * @param {string} theDocument - the current file name.\n    * @returns {object} The file indexes.\n    */\n\n  }, {\n    key: 'populateReference',\n    value: function populateReference(jsonObject, parent, theDocument) {\n      /* eslint-disable no-param-reassign */\n      /* eslint-disable no-unused-expression */\n      var jsonObjectKeys = Object.keys(jsonObject);\n      var jsonObjectKeysLength = jsonObjectKeys.length;\n      var index = 0;\n      parent.reference[theDocument] = {};\n      var tokenIndex = function tokenIndex() {\n        jsonObject[index].forEach(function (word) {\n          /* eslint-disable no-unused-expressions */\n          parent.reference[theDocument][word] !== undefined ? parent.reference[theDocument][word].push(index) : (parent.reference[theDocument][word] = [], parent.reference[theDocument][word].push(index));\n        });\n        index += 1;\n      };\n      while (index < jsonObjectKeysLength) {\n        tokenIndex();\n      }\n      parent.documentFiles[theDocument] = jsonObject;\n      return parent.reference[theDocument];\n    }\n\n    /** filter text input\n    * @param {string} value - the current search query(array or string).\n    * @returns {array} The filtered search query.\n    */\n\n  }, {\n    key: 'inputFIlter',\n    value: function inputFIlter(value) {\n      return value.replace(/[^\\w\\s]/gi, '').split(' ').filter(function (item) {\n        return (/\\S/gi.test(item)\n        );\n      });\n    }\n  }]);\n\n  return Utils;\n}();\n\nmodule.exports = Utils;\n\n},{}]},{},[2]);\n"],"file":"spec.js"}