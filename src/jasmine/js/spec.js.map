{"version":3,"names":[],"mappings":"","sources":["spec.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar InvertedIndex = require('../../js/Inverted-index.js');\n\nvar Utils = require('../../js/Inverted-Index-Utility.js');\n\nvar index = new InvertedIndex(Utils);\n\nindex.createIndex('./src/public/uploads/books.json').then(function () {\n  var fileContents = index.currentFile;\n  describe('Read book data', function () {\n    it('Should return a valid JSON array', function () {\n      expect(Array.isArray(fileContents)).toBe(true);\n    });\n    it('Should return a non empty JSON array', function () {\n      expect(fileContents.length > 1).toBe(true);\n    });\n    it('Should remove duplicates from array', function () {\n      var duplicate = ['a', 'b', 'c', 'd', 'e', 'a', 'b', 'c', 'd', 'e'];\n      expect(index.utility.unique(duplicate)).toEqual(['a', 'b', 'c', 'd', 'e']);\n    });\n    it('Should return a JSON array which contains objects only', function () {\n      var answer = true;\n      var count = 0;\n      while (count < fileContents.length) {\n        if (_typeof(fileContents[count]) != 'object' || Array.isArray(fileContents[count])) {\n          answer = false;\n        }\n        count += 1;\n      }\n      expect(answer).toBe(true);\n    });\n    it('Should return a JSON array which has keys (title and text)', function () {\n      var answer = true;\n      var count = 0;\n      while (count < fileContents.length && answer) {\n        if (fileContents[count].title === undefined || fileContents[count].text === undefined) {\n          answer = false;\n        }\n        count += 1;\n      }\n      expect(answer).toBe(true);\n    });\n    it('Should return a JSON array which has valid string entries for keys(title, text)', function () {\n      var answer = true;\n      var count = 0;\n      while (count < fileContents.length) {\n        if (typeof fileContents[count].title != 'string' || typeof fileContents[count].text != 'string') {\n          answer = false;\n        }\n        count += 1;\n      }\n      expect(answer).toBe(true);\n    });\n    it('Should return the correct filename of the uploaded file', function () {\n      var answer = index.utility.formatFileName('src/jasmine/books.json');\n      expect(answer).toEqual('books.json');\n    });\n  });\n\n  describe('Populate Index', function () {\n    describe('On file upload', function () {\n      it('Should create the index once the JSON file has been read', function () {\n        expect(_typeof(index.reference['books.json'])).toEqual('object');\n      });\n\n      it('Should create an accurate index object', function () {\n        expect(index.getIndex('/src/public/uploads/books.json').alice[0]).toEqual(0);\n        expect(index.getIndex('/src/public/uploads/books.json').lord[0]).toEqual(1);\n        expect(index.getIndex('/src/public/uploads/books.json').a[1]).toEqual(1);\n      });\n      it('Should create an inverted index', function () {\n        var verdict = true;\n        var indexContent = index.reference['books.json'];\n        for (var value in indexContent) {\n          if (!Array.isArray(indexContent[value]) || isNaN(indexContent[value][0])) {\n            verdict = false;\n          }\n        }\n        expect(verdict).toEqual(true);\n      });\n\n      index.createIndex('./src/public/uploads/tests.json').then(function () {\n        it('Should not overwrite the previously created index', function () {\n          var indexBefore = index.reference['books.json'];\n          var indexAfter = index.reference['tests.json'];\n          expect((typeof indexBefore === 'undefined' ? 'undefined' : _typeof(indexBefore)) == 'object' && (typeof indexAfter === 'undefined' ? 'undefined' : _typeof(indexAfter)) == 'object').toBe(true);\n        });\n\n        describe('Search Index', function () {\n          describe('Search results', function () {\n            it('Should return the correct result for single word searches', function () {\n              expect(_typeof(index.searchIndex('Lord', ['books.json']))).toEqual('object');\n            });\n            it('Should filter non word search queries', function () {\n              var theSearch = Object.keys(index.searchIndex('alliance ** && $$$', ['books.json'])['books.json']);\n\n              expect(theSearch).toEqual(['alliance']);\n            });\n\n            it('Should return correct search results for multiple word queries', function () {\n              expect(index.searchIndex('lord of the rings', ['books.json'])['books.json']).toEqual({\n                lord: [1],\n                of: [0, 1],\n                the: [1],\n                rings: [1]\n              });\n            });\n          });\n\n          it('Should not take too long to execute', function () {\n            var startTime = performance.now();\n            index.searchIndex('lord of the rings', ['books.json']);\n            var endTime = performance.now();\n            expect(endTime - startTime < 5000).toBeTruthy();\n          });\n\n          it('It should ensure that filename argument is optional', function () {\n            var result = index.searchIndex('lord of the rings')['books.json'];\n            expect(Object.keys(result).sort()).toEqual(Object.keys({\n              lord: [1],\n              of: [0, 1],\n              the: [1],\n              rings: [1]\n            }).sort());\n          });\n\n          it('It should accept an array of argument', function () {\n            var result = index.searchIndex(['lord', 'of', 'the', 'rings'], ['books.json'])['books.json'];\n            expect(result).toEqual({\n              lord: [1],\n              of: [0, 1],\n              the: [1],\n              rings: [1]\n            });\n          });\n\n          describe('Get Index', function () {\n            it('Should take the file url of the JSON file as an argument', function () {\n              expect(index.getIndex('/src/public/uploads/books.json').a[1]).toEqual(1);\n            });\n          });\n        });\n      });\n    });\n  });\n});\n\n},{\"../../js/Inverted-Index-Utility.js\":2,\"../../js/Inverted-index.js\":3}],2:[function(require,module,exports){\n'use strict';\n\n/**\n* Helper Class for creating an inverted index.\n*/\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar InvertedIndexUtility = function () {\n  function InvertedIndexUtility() {\n    _classCallCheck(this, InvertedIndexUtility);\n  }\n\n  _createClass(InvertedIndexUtility, null, [{\n    key: 'unique',\n\n    /** remove array duplicates.\n    * @param {array} array - The array to be filtered.\n    * @returns {array} The filtered array.\n    */\n    value: function unique(array) {\n      if (Array.isArray(array)) {\n        var _ret = function () {\n          var checked = {};\n          return {\n            v: array.filter(function (item) {\n              if (!checked[item]) {\n                checked[item] = true;\n                return item;\n              }\n              return null;\n            })\n          };\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n      return [];\n    }\n\n    /**\n    * JSON file reader.\n    * @param {string} url - The url of JSON file.\n    * @param {function} callback - the callback function\n    * takes in the responseData parameter as argument.\n    * @returns {function} The callback value.\n    */\n\n  }, {\n    key: 'getJSON',\n    value: function getJSON(url, callback) {\n      /* eslint-disable no-undef */\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'json';\n      xhr.onreadystatechange = function changed() {\n        if (this.readyState === XMLHttpRequest.DONE) {\n          if (this.status === 200) {\n            return callback(this);\n          }\n        }\n        return this.statusText;\n      };\n      xhr.onerror = xhr.statusText;\n      xhr.send();\n    }\n\n    /**\n    * check if object is a valid json file.\n    * @param {object} jsonObject - The JSON file content.\n    * @returns {boolean} ans - The check for jsonObject validity.\n    */\n\n  }, {\n    key: 'isValidJson',\n    value: function isValidJson(jsonObject) {\n      var jsonObjectKeys = null;\n      var jsonObjectLength = null;\n      try {\n        jsonObjectKeys = Object.keys(jsonObject);\n        jsonObjectLength = jsonObjectKeys.length;\n      } catch (error) {\n        return false;\n      }\n      var count = 0;\n      var ans = true;\n      if (jsonObjectLength > 0) {\n        while (count < jsonObjectLength) {\n          var hasValidTitle = jsonObject[count].title !== undefined && jsonObject[count].title.length > 0 && typeof jsonObject[count].title === 'string';\n          var hasValidText = jsonObject[count].text !== undefined && jsonObject[count].text.length > 0 && typeof jsonObject[count].text === 'string';\n          if (!(hasValidTitle && hasValidText)) {\n            ans = false;\n            return ans;\n          }\n          count += 1;\n        }\n      } else {\n        ans = false;\n      }\n      return ans;\n    }\n\n    /**\n    * format file url to acceptable file name format.\n    * @param {string} url - the current file url.\n    * @returns {string} The new valid file name.\n    */\n\n  }, {\n    key: 'formatFileName',\n    value: function formatFileName(url) {\n      try {\n        var matcher = new RegExp(/\\/\\w+.json/, 'gi');\n        return matcher.exec(url).toString().slice(1);\n      } catch (error) {\n        throw error;\n      }\n    }\n\n    /**\n    * save file and sort docs in json.\n    * @param {object} jsonObject - a json object.\n    * @returns {object} an object containing he saved tokens and jsonObject.\n    */\n\n  }, {\n    key: 'saveTokens',\n    value: function saveTokens(jsonObject) {\n      var _this = this;\n\n      try {\n        var _ret2 = function () {\n          var tokens = {};\n          var words = [];\n          jsonObject.forEach(function (documentObject, index) {\n            var token = '';\n            token = documentObject.title + ' ' + documentObject.text;\n            var uniqueTokens = _this.unique(token.toLowerCase().match(/\\w+/g).sort());\n            tokens[index] = uniqueTokens;\n            words = words.concat(uniqueTokens);\n          });\n          return {\n            v: { tokens: tokens, jsonObject: jsonObject, words: words }\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      } catch (error) {\n        throw error;\n      }\n    }\n\n    /**\n    * populate the object reference and document attribute.\n    * @param {object} jsonObject - the jsonObject.\n    * @param {object} parent - the current (this) object.\n    * @param {string} theDocument - the current file name.\n    * @returns {object} The file indexes.\n    */\n\n  }, {\n    key: 'populateReference',\n    value: function populateReference(jsonObject, parent, theDocument) {\n      /* eslint-disable no-param-reassign */\n      /* eslint-disable no-unused-expression */\n      var jsonObjectKeys = Object.keys(jsonObject);\n      var jsonObjectKeysLength = jsonObjectKeys.length;\n      var index = 0;\n      parent.reference[theDocument] = {};\n      var tokenIndex = function tokenIndex() {\n        jsonObject[index].forEach(function (word) {\n          /* eslint-disable no-unused-expressions */\n          parent.reference[theDocument][word] !== undefined ? parent.reference[theDocument][word].push(index) : (parent.reference[theDocument][word] = [], parent.reference[theDocument][word].push(index));\n        });\n        index += 1;\n      };\n      while (index < jsonObjectKeysLength) {\n        tokenIndex();\n      }\n      parent.documentFiles[theDocument] = jsonObject;\n      return parent.reference[theDocument];\n    }\n\n    /** filter text input\n    * @param {string} value - the current search query(array or string).\n    * @returns {array} The filtered search query.\n    */\n\n  }, {\n    key: 'inputFIlter',\n    value: function inputFIlter(value) {\n      if (Array.isArray(value)) {\n        value = value.join(' ');\n      }\n      return value.toLowerCase().replace(/[^\\w\\s]/gi, '').split(' ').filter(function (item) {\n        return (/\\S/gi.test(item)\n        );\n      });\n    }\n  }]);\n\n  return InvertedIndexUtility;\n}();\n\nmodule.exports = InvertedIndexUtility;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Class for creating an inverted index.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar InvertedIndex = function () {\n  /**\n  * Instantiate an inverted index object.\n  * @param {object} utility - The InvertedIndexHelper class.\n  */\n  function InvertedIndex(utility) {\n    _classCallCheck(this, InvertedIndex);\n\n    this.utility = utility;\n    this.reference = {};\n    this.documentFiles = {};\n    this.currentFile = [];\n    this.currentDocuments = [];\n    this.allWords = [];\n  }\n\n  /**\n  * Create an inverted index from file\n  * @param {string} url - The json file url.\n  * @returns {object} The reference object for current file.\n  */\n\n\n  _createClass(InvertedIndex, [{\n    key: 'createIndex',\n    value: function createIndex(url) {\n      var _this = this;\n\n      /* eslint-disable no-unused-vars */\n      /* eslint-disable consistent-return */\n      return new Promise(function (resolve, reject) {\n        _this.utility.getJSON(url, function (data) {\n          resolve(data.response);\n        });\n      }).then(function (jsonObject) {\n        try {\n          if (_this.utility.isValidJson(jsonObject)) {\n            var savedTokens = _this.utility.saveTokens(jsonObject);\n            var documentName = _this.utility.formatFileName(url);\n            _this.currentFile = jsonObject;\n            _this.utility.populateReference(savedTokens.tokens, _this, documentName);\n            _this.currentDocuments.push(documentName);\n            _this.allWords = _this.utility.unique(_this.allWords.concat(savedTokens.words));\n            return _this.reference[documentName];\n          }\n        } catch (error) {\n          throw error;\n        }\n      });\n    }\n\n    /**\n    * Get Created inverted index.\n    * @param {string} url - The file url of the json document.\n    * @returns {object} The reference object for current file.\n    */\n\n  }, {\n    key: 'getIndex',\n    value: function getIndex(url) {\n      var documentName = this.utility.formatFileName(url);\n      return this.reference[documentName];\n    }\n\n    /**\n    * Search the inverted index.\n    * @param {string} value - The current search query.\n    * @param {array} documentNames - an array of current files to searxh.\n    * @returns {object} An object with the accurate search results.\n    */\n\n  }, {\n    key: 'searchIndex',\n    value: function searchIndex(value, documentNames) {\n      var _this2 = this;\n\n      /* eslint-disable no-unused-expressions */\n      /* eslint-disable no-unused-vars */\n      /* eslint-disable no-nested-ternary */\n      this.searchReturn = {};\n      if (value !== (null || undefined)) {\n        if (documentNames === undefined || documentNames.length < 1 || documentNames === '') {\n          documentNames = this.currentDocuments;\n        }\n        this.utility.inputFIlter(value).filter(function (word) {\n          return _this2.allWords.indexOf(word) !== -1;\n        }).forEach(function (word) {\n          documentNames.forEach(function (documentFile) {\n            var docKeys = Object.keys(_this2.reference[documentFile]);\n            _typeof(_this2.searchReturn[documentFile]) === 'object' && !Array.isArray(_this2.searchReturn[documentFile]) ? docKeys.indexOf(word) !== -1 ? _this2.searchReturn[documentFile][word] = _this2.reference[documentFile][word] : null : docKeys.indexOf(word) !== -1 ? (_this2.searchReturn[documentFile] = {}, _this2.searchReturn[documentFile][word] = _this2.reference[documentFile][word]) : null;\n          });\n        });\n        if (Object.keys(this.searchReturn).length < 1) {\n          return { 'No results found : please refine your search query': '' };\n        }\n        return this.searchReturn;\n      }\n      return { 'Please enter search query and select index to search': '' };\n    }\n  }]);\n\n  return InvertedIndex;\n}();\n\nmodule.exports = InvertedIndex;\n\n},{}]},{},[1]);\n"],"file":"spec.js"}